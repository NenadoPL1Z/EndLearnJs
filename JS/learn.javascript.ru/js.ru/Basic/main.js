/**
Переменная - https://learn.javascript.ru/variables

//  Мы можем объявить переменные для хранения данных с помощью ключевых слов       var, let или const.
//

//  let – это современный способ объявления.

//  var – это устаревший способ объявления. Обычно мы вообще не используем         его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое         слово "var" на случай, если это всё-таки вам понадобится.

//  const – похоже на let, но значение переменной не может изменяться.

//  Переменные должны быть названы таким образом, чтобы мы могли легко             понять, что у них внутри.

        Типы данных - https://learn.javascript.ru/types

    Числа:

//Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.
//
//Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
//
//NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции

//Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
//Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

    Строки:

//В JavaScript существует три типа кавычек.

//Двойные кавычки: "Привет".
//Одинарные кавычки: 'Привет'.
//Обратные кавычки: `Привет`.
//Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.
//
//Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}.
//  let flex = 21 + 21;
//  console.log(`This number ${flex}?`);

    True - False

//No comments

    null

//если переменной будет присвоен null то она будет равна ничему

    undefined

// если в переменной ничего не будет то будет такой тип

    Итог:

//В JavaScript есть 8 основных типов.
//
//number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
//bigint для целых чисел произвольной длины.
//string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
//boolean для true/false.
//null для неизвестных значений – отдельный тип, имеющий одно значение null.
//undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
//object для более сложных структур данных.
//symbol для уникальных идентификаторов.
//Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
//
//Имеет две формы: typeof x или typeof(x).
//Возвращает строку с именем типа. Например, "string".
//Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

            Взаимодействие: alert, prompt, confirm - https://learn.javascript.ru/alert-prompt-confirm

        //alert
//показывает сообщение.

        //prompt
//показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.

        //confirm
//показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.

            Преобразование типов  - https://learn.javascript.ru/type-conversions#itogo



//Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.
//
//Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
//
//Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
//
//Преобразование подчиняется правилам:
//
//Значение    Становится…
//undefined    NaN
//null    0
//true / false    1 / 0
//string    Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
//Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
//
//Подчиняется правилам:
//
//Значение    Становится…
//0, null, undefined, NaN, ""    false
//любое другое значение    true
//Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:
//
//undefined при численном преобразовании становится NaN, не 0.
//"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.
//В этой главе мы не говорили об объектах. Мы вернёмся к ним позже, в главе Преобразование объектов в примитивы, посвящённой только объектам, сразу после того, как узнаем больше про основы JavaScript.

            Операторы сравнения - https://learn.javascript.ru/comparison#sravnenie-raznyh-tipov

//Операторы сравнения возвращают значения логического типа.
//Строки сравниваются посимвольно в лексикографическом порядке.
//Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
//Значения null и undefined равны == друг другу и не равны любому другому значению.
//Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.


            Оператор объединения с null '??' - https://learn.javascript.ru/nullish-coalescing-operator#itogo

//В этой статье мы будем говорить, что значение выражения «определено», если оно отличается от null или undefined.
//
//Оператор объединения с null представляет собой два вопросительных знака ??.
//
//Результат выражения a ?? b будет следующим:
//
//a, если значение a определено,
//b, если значение a не определено.
//То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
//
//Оператор объединения с null не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно «определённое».
//
//
//Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.
//
//Используется для присвоения переменным значений по умолчанию:
//
//// будет height=100, если переменная height равна null или undefined
//height = height ?? 100;
//Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.
//
//Запрещено использовать вместе с || или && без явно указанных круглых скобок.

            Циклы while и for - https://learn.javascript.ru/while-for
//Мы рассмотрели 3 вида циклов:
//
//while – Проверяет условие перед каждой итерацией.
//do..while – Проверяет условие после каждой итерации.
//for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
//Чтобы организовать бесконечный цикл, используют конструкцию while (true). При этом он, как и любой другой цикл, может быть прерван директивой break.
//
//Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
//
//Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.
//
//Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.
                Функции -

//Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.
//
//Например, функции, начинающиеся с "show" обычно что-то показывают.
//
//Функции, начинающиеся с…
//
//"get…" – возвращают значение,
//"calc…" – что-то вычисляют,
//"create…" – что-то создают,
//"check…" – что-то проверяют и возвращают логическое значение, и т.д

                Объекты - https://learn.javascript.ru/object
//let user = {
//  name: "John",
//  age: 18,
//  "big boss": true
//};
//// добовляем объекту user новый ключь Rodion со значением "Debil";
//user.Rodion = "Debil";
//// удаляем ключь из объекта
//delete user.age;
//console.log(user)
//Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
//
//Они хранят свойства (пары ключ-значение), где:
//
//Ключи свойств должны быть строками или символами (обычно строками).
//Значения могут быть любого типа.
//Чтобы получить доступ к свойству, мы можем использовать:
//
//Запись через точку: obj.property.
//Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
//Дополнительные операторы:
//
//Удаление свойства: delete obj.prop.
//Проверка существования свойства: "key" in obj.
//Перебор свойств объекта: цикл for for (let key in obj).
//То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.
//
//В JavaScript есть много других типов объектов:
//
//Array для хранения упорядоченных коллекций данных,
//Date для хранения информации о дате и времени,
//Error для хранения информации об ошибке.
//… и так далее.
//У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.
//
//Объекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему. Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.
                Копирование объектов и ссылки - https://learn.javascript.ru/object-copy
//Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.
//
//Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.
//
//Для «простого клонирования» объекта можно использовать Object.assign. Необходимо помнить, что Object.assign не делает глубокое клонирования объекта. Если внутри копируемого объекта есть свойство, значение которого не является примитивом, оно будет передано по ссылке. Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки _.cloneDeep(obj).

                Опциональная цепочка - https://learn.javascript.ru/optional-chaining
//Синтаксис опциональной цепочки ?. имеет три формы:
//
//obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
//obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
//obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.
//Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть выражения на равенство null/undefined, и продолжает дальнейшее вычисление, только если это не так.
//
//Цепочка ?. позволяет без возникновения ошибок обратиться к вложенным свойствам.
//
//Тем не менее, нужно разумно использовать ?. — только там, где это уместно, если допустимо, что левая часть не существует. Чтобы таким образом не скрывать возможные ошибки программирования.
                Символы - https://learn.javascript.ru/symbol
//Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
//
//Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.
//
//Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.
//
//Символы имеют два основных варианта использования:
//
//«Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.
//
//Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.
//
//Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.
//
//Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.
                Числа - https://learn.javascript.ru/number#sposoby-zapisi-chisla
//let x = 2e2; // 2 * (10 ** 2)
//console.log(x)
//let y = 2e-2; // 2 / (10 ** 2)
//console.log(y)
//console.log(0xff3636)
//// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
//console.log(12345..toString(36))
//console.log(Math.floor(3.9)) // округление в меньшую сторону
//console.log(Math.ceil(3.1)) // округление в большую сторону
//console.log(Math.round(3.5)) // округление до ближайшего целого (.1 - .4 в меньщую)
//console.log(Math.trunc(-9.9)) // убираем дробную часть
//let n = 12.34.toFixed(1); // говорит сколько чисел будет после запято, но возвращает строку
//console.log(Number(n))
//console.log(1e500)
//console.log(+((0.1 + 0.2).toFixed(1)));
//// запись без toFixed
//console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
//Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
//console.log(0b1)
////isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
//console.log(isNaN("12")) // false
//console.log(isNaN("Hello")) // true
////isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
//console.log(isFinite("12")) // true
//console.log(isFinite("Hello"))
//console.log(isFinite(Infinity))
////Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
//console.log(Object.is(NaN, NaN))
//console.log(Object.is(0, -0))
////Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:
//console.log(parseInt("100px"))
//console.log(parseFloat("105.50em"))
//console.log(parseInt("10.1px"))
//console.log(parseFloat("10px"))
////Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру
////Второй аргумент parseInt(str, radix)
//// Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д
//let x = (Math.random() * 400) // random
//console.log(Math.round(x))
//console.log(Math.max(1, 2, 3, 4, 100, 1000))
//console.log(Math.min(1, 2, 3, 4, 100, 1000))
//console.log(Math.pow(2, 5))

                Строки - https://learn.javascript.ru/string

//Символ    Описание
//\n    Перевод строки
//\r    Возврат каретки: самостоятельно не используется. В текстовых файлах Windows для перевода строки используется комбинация символов \r\n.
//\', \"    Кавычки
//\\    Обратный слеш
//\t    Знак табуляции
//\b, \f, \v    Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.
//\xXX    Символ с шестнадцатеричным юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.
//\uXXXX    Символ в кодировке UTF-16 с шестнадцатеричным кодом XXXX, например, \u00A9 — юникодное представление знака копирайта, ©. Код должен состоять ровно из 4 шестнадцатеричных цифр.
//\u{X…XXXXXX} (от 1 до 6 шестнадцатеричных цифр)    Символ в кодировке UTF-32 с шестнадцатеричным кодом от U+0000 до U+10FFFF. Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом.
//// length - считает длинну строки
// пробел и символы тоже считаются
//let b = "Hello ,";
//console.log(b.length)
//// index - при пустой строке выведет undefined
//b = "Hello";
//console.log(b[0],b[4])
//console.log(b[6])
//// альтернатива - при пустой строке выведет пустую строку
//console.log(b.charAt(2))
//console.log(b.charAt(29))
//// регистры
//console.log(b.toLowerCase()) // нижний
//console.log(b.toUpperCase()) // верхний
//b = "Hello my friend holla ho hel"
//console.log(b.indexOf("He"))

        Массивы - https://learn.javascript.ru/array
//let arr = ["Яблоко", "Апельсин", "Слива"];
// console.log(arr[2])
// arr[2] = "Банан";
// console.log(arr[2])
// console.log(arr[3])
// arr[3] = "Арбуз"
// console.log(arr[3])
// console.log(arr.length)
// console.log(arr)
// let arrTwo = ["Яблоко", {name: "Джон"}, function() {return ("Hello");}, false];
// console.log(arrTwo[2]())
// arr.push("Name") // добовляем в конец
// console.log(arr)
// console.log(arr.shift()) // удаляем элемент с начала со сдвигом влево и возворщаем его
// console.log(arr)
// console.log(arr.pop()) // удаляет элемент с конца и возворащает его
// console.log(arr)
// arr.unshift("Яблоко") // добовляем в началао
// console.log(arr)
// arr.push("Киви","Слива") // добавили сразу 2 элемента
// console.log(arr)
// arr.unshift("Абрикос", "Дыня") // добовляем сразу 2 элемента
// console.log(arr)
// let a = arr; // показывает как работает в памяти
// a.pop() // 2 переменные ссылкаются на 1 объект в памяти
// console.log(arr) // видим результат
// let name = ["Вася", "Володя", "Владимир"]
// for (let n of name) {
//   n += '1'
//   console.log(n)
// }
// let x = [];
// x[122] = "Name"
// x[14] = "X"
// console.log(x)
// Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

// Объявление:

// // квадратные скобки (обычно)
// let arr = [item1, item2...];

// // new Array (очень редко)
// let arr = new Array(item1, item2...);
// Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

// Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.

// Если мы уменьшаем length вручную, массив укорачивается.

// Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

// push(...items)добавляет items в конец массива.
// pop() удаляет элемент в конце массива и возвращает его.
// shift() удаляет элемент в начале массива и возвращает его.
// unshift(...items) добавляет items в начало массива.
// Чтобы пройтись по элементам массива:

// for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
// for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
// for (let i in arr) – никогда не используйте для массивов!
// Мы вернёмся к массивам и изучим другие методы добавления, удаления, выделения элементов и сортировки массивов в главе: Методы массивов.

        Свойства массивов
//// delete в массивах нельзя использовать delete arr[1]
//// splice
//let arr = ["Арбуз", "Яблоко", "Банан"]
//arr.splice(1, 2) // нчиная с 1 индекса удалить 2 элемента
//console.log(arr)
//arr = ["Арбуз", "Яблоко", "Банан"]
//arr.splice(1, 2, "Апельсин", "Сахар") // нчиная с 1 индекса удалить 2 элемента и заменить попорядку другими элементами
//console.log(arr)
//// вставляем без удаления
//arr = ["Арбуз", "Яблоко", "Банан"]
//arr.splice(2, 0, "Дыня", "Вишня")
//console.log(arr)
//let x = arr.slice(2, 4) // копируем со второго индекса и до 4 (4 не включается)
////x =  arr.slice() скопировал бы весь массив
//console.log(x)
//
//let x1 = [1, 2, 3];
//let x2 = [3, 4, 5];
//let x3 = [6, 7, 8];
//let x4 = []
//console.log(x4.concat(x1, x2, x3, 9, 10)) // concat объединил все массивы и плюсом добавил 2 значения

//…Но если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается concat как массив: вместо него добавляются его числовые свойства.
//
//Для корректной обработки в объекте должны быть числовые свойства и length:
//
//let arr = [1, 2];
//
//let arrayLike = {
//  0: "что-то",
//  1: "ещё",
//  [Symbol.isConcatSpreadable]: true,
//  length: 2
//};
//
//alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
// let arr = ["Яблоко", "Апельсин", "Банан"];
// console.log(arr.indexOf("Банан")) // ищет индекс по имени
// console.log(arr.lastIndexOf("Банан")) // ищет индекс с право на лево
// console.log(arr.includes("Банан")) // ищет в массиве элемент если он есть true иначе false
// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Валера"}
// ];
// let user = users.find(item => item.id == 1);
// console.log(user)
// console.log(users[1].name)
//Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
// методом map по очерёдно проходимся по каждому элементу

//let a = ["Фркукт", "Овощь", "Вредное"].map(function(item) {
//  return `Длянна ${item} = ${item.length}`;
//});
//console.log(a)
//let arr = [1, 2, 15, 4, 3, 5];
//arr.sort() // сортируем массив (строками: "2" > "15")
//console.log(arr)
//
//// сортируем с добавлением логики
//function sorted(a, b) {
//  if (a > b) return 1;
//  if (a < b) return -1;
//  if (a == b) return 0;
//};
//
//arr.sort(sorted)
//console.log(arr)
//
//// reverse() меняет порядок наобарот
//console.log(arr.reverse())
//
//// split - разбивает строку на массив
//let name = "Петя, Вася, Надя";
//let names = name.split(", ");
//console.log(names);
//for (let x of names) console.log(`Сообщения получит ${x}.`);
//names = name.split(", ", 2); // второй аргумент для ограничения массива
//for (let x of names) console.log(`Сообщения получит ${x}.`);
//
//join - объединяет массив в строку
let str = names.join(' и ');
console.log(str)


// reduce

// let value = arr.reduce(function(previousValue, item, index, array) {
//   // ...
// }, [initial]);
// Аргументы:

// previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.
arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

console.log(result); // 15

// вызов reduce при пустом массиве без 1-го параметра выдаст ошибку

//arr.reduceRight - работает аналогично, но проходит по массиву справа налево.

console.log(Array.isArray(arr)) // проверяет явлается ли переменная массивом или нет

//Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
// Для поиска среди элементов:

// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
// Для перебора элементов:

// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:

// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
// Дополнительно:

// Array.isArray(arr) проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// arr.some(fn)/arr.every(fn) проверяет массив.

// Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

// arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

// Полный список есть в справочнике MDN.

// На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но это гораздо проще, чем кажется.

// Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.

// Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу и ищите правильный метод. Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы без особых усилий.
*/